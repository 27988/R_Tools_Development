var_type <- var_type_identify(df=data,exclude_vars=exclude_vars)
#Identify numeric variables if is.null(num_vars)
if (is.null(num_vars)) {
num_vars <- var_type[[1]]
}
#Identify character/categorical variables if is.null(factor_vars)
if (is.null(factor_vars)) {
factor_vars <- var_type[[2]]
}
#Correlation for categorical variables
library(pedometrics)
if (is.null(factor_vars)) {
message("No numeric variables in dataset")
}  else {    cramer_d <- data[,which(colnames(data) %in% factor_vars)]}
if (length(cramer_d) > 0 ) {
cramer_vars <- matrix(0,((dim(cramer_d)[2]*(dim(cramer_d)[2]-1))/2),3)
cramer_v <- cramer(cramer_d)
c=0
for (j in 1:dim(cramer_v)[2]) {
if ((j+1) <= dim(cramer_v)[2]) {for (k in (j+1):dim(cramer_v)[2]) {
c=c+1
cramer_vars[c,1] <- rownames(cramer_v)[j]
cramer_vars[c,2] <- colnames(cramer_v)[k]
cramer_vars[c,3] <- cramer_v[j,k]
}
}
}
cramer_vars <- data.frame(cramer_vars)
colnames(cramer_vars) <- c("Variable1", "Variable2", "Coeff")
cramer_vars$Coeff <- as.numeric(as.character(cramer_vars$Coeff))
#Track the variables that are highly correlated
corr_categorical <- cramer_vars[cramer_vars[["Coeff"]] >= cutoff,]
}
#Correlation for numeric variables
if (is.null(num_vars)) {
message("No numeric variables in dataset")
} else {corr_d <- data[,which(colnames(data) %in% num_vars)]}
if (length(corr_d) > 0 ) {
corr_vars <- matrix(0,((dim(corr_d)[2]*(dim(corr_d)[2]-1))/2),3)
corr_v <- cor(corr_d, use="complete.obs", method= corr_method)
c=0
for (j in 1:dim(corr_v)[2]) {
if ((j+1) <= dim(corr_v)[2]) {for (k in (j+1):dim(corr_v)[2]) {
c=c+1
corr_vars[c,1] <- rownames(corr_v)[j]
corr_vars[c,2] <- colnames(corr_v)[k]
corr_vars[c,3] <- corr_v[j,k]
}
}
}
corr_vars <- data.frame(corr_vars)
colnames(corr_vars) <- c("Variable1", "Variable2", "Coeff")
corr_vars$Coeff <- as.numeric(as.character(corr_vars$Coeff))
#Track the variables that are highly correlated
corr_num <- corr_vars[corr_vars[["Coeff"]] >= cutoff,]
}
if (filetype_out == "list"){
corr_list <- list()
corr_list$numeric_list <- corr_num
corr_list$categorical_list <- corr_categorical
return(corr_list)
} else if (tolower(filetype_out) == "xls" | tolower(filetype_out) == "xlsx") {
write.xlsx(corr_num, file=output_path, sheetName="Numeric List", row.names=FALSE)
write.xlsx(corr_categorical, file=output_path, sheetName="Categorical List", append=TRUE, row.names=FALSE)
} else stop("ERROR: Type of output file should either be list, xls or xlsx")
}
#Test
library(xlsx)
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
a = multicoll_chk(df=data,num_vars=c("yrs.service","yrs.since.phd"),factor_vars = c("rank","discipline"))
a$numeric_list
a$categorical_list
a = multicoll_chk(df=data)
a[[1]]
a[[2]]
a = multicoll_chk(df=data,exclude_vars="patient_id")
a[[1]]
a[[2]]
a = multicoll_chk(df=data,exclude_vars=NULL,filetype_out="xls",output_path="/stats/projects/all/R_Tools_Development/data/multicoll_chk.xls")
#' Partition data into train and test datasets.
#'
#' @param df A dataframe if filetype is dataframe or file path.
#' @param filetype Type of file read. Provide extension of file if not dataframe. Permissible filetypes are Rds, rds, csv, xls and xlsx.
#' @param seed Random seed value.
#' @param splitkey A key (variable) used to identify all records of the same entity (e.g.patient ID).
#' @param stratifyby A single column name or vector of column names that will be used to stratify data.
#' @param trainprop Proportion that should be retained in train dataset. Value ranges between 0 and 1. Default is 0.70.
#' @return Dataframes as train and test.
#' @examples
#' res = split(df=data,filetype = "dataframe", seed=50, splitkey = NULL, stratifyby = c("rank","discipline"), trainprop=0.70)
#' res = split(df=data, filetype = "dataframe",seed=50, splitkey = NULL, stratifyby = c("discipline"), trainprop=0.70)
#' res = split(df="/stats/projects/all/R_Tools_Development/data/salaries_data.xlsx", filetype = "xlsx",seed=50, splitkey = NULL, stratifyby = c("discipline"), trainprop=0.70)
#' res = split(df="/stats/projects/all/R_Tools_Development/data/salaries_data.csv", filetype = "csv", seed=50, splitkey = NULL, stratifyby = NULL,  trainprop=0.50)
#' res = split(df=data, filetype = "dataframe",seed=50, splitkey = "patient_id", stratifyby = c("rank"),  trainprop=0.50)
#' train <- res$train; test <- res$test
split <- function(df, filetype_in = "dataframe",seed=50, splitkey = NULL, stratifyby = NULL, trainprop=0.70) {
set.seed(seed)
data <- filetype(df=df,filetype_in=filetype_in)
#Check if splitkey has valid column name
if (!(splitkey %in% colnames(data))) {stop("ERROR: splitkey is not a valid column name")}
#Check if trainprop is valid
if (trainprop > 1 | trainprop <0) {stop("ERROR: trainprop should be <= 1 and >= 0")}
#If unique ID is not required
if (is.null(splitkey)) {
# If stratified sampling is required
if (!is.null(stratifyby)){
list_t <- NULL
list_t <- data[[stratifyby[1]]]
if (length(stratifyby) > 1) {
for (i in 2: length(stratifyby)){
list_t <- list(list_t,data[[stratifyby[i]]])
}
}
sp <- base::split(seq_len(nrow(data)), list_t)
samples <- lapply(sp, function(x) sample(x, replace=F,size=trainprop*length(x)))
train <- data[unlist(samples), ]
test <- data[-unlist(samples),]
} else {
samples <- sample(1:dim(data)[1],replace=F,size=trainprop*dim(data)[1])
train <- data[samples,]
test <- data[-samples,]
}
} else {
unique_id <- unique(data[[splitkey]])
# If stratified sampling is required
if (!is.null(stratifyby)){
list_t <- NULL
list_t <- data[[stratifyby[1]]]
if (length(stratifyby) > 1) {
for (i in 2: length(stratifyby)){
list_t <- list(list_t,data[[stratifyby[i]]])
}
}
sp <- base::split(seq_len(nrow(data)), list_t)
samples <- lapply(sp, function(x) sample(x, replace=F,size=trainprop*length(x)))
samples <- unique_id[unlist(samples)]
train <- data[data[[splitkey]] %in% samples, ]
test <- data[!(data[[splitkey]] %in% samples),]
} else {
samples <- sample(1:dim(data)[1],replace=F,size=trainprop*dim(data)[1])
samples <- unique_id[samples]
train <- data[data[[splitkey]] %in% samples,]
test <- data[!(data[[splitkey]] %in% samples),]
}
}
split.data <- list()
split.data$train <- train
split.data$test <- test
#Check if result is produced correctly
if (dim(train)[1] == 0 | dim(test)[1] == 0) {
stop("ERROR: One or a combination of the following issues have occurred:
1. stratifyby is a numeric variable or has too many levels
2. trainprop in combination with stratifyby is too small to produce a valid data cut")}
return(split.data)
}
#Test
library(xlsx)
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
res = split(df=data,filetype_in = "dataframe", seed=50, splitkey = NULL, stratifyby = c("rank","discipline"), trainprop=0.37)
#' Read various filetypes to convert to dataframe.
#'
#' @param df A dataframe if filetype is dataframe or file path.
#' @param filetype_in Type of file read. Provide extension of file if not dataframe. Permissible filetypes are Rds, rds, csv, xls and xlsx.
#' @return A dataframe.
#' @examples
#' data = filetype((data="/stats/projects/all/R_Tools_Development/data/salaries_data.Rds",filetype_in="Rds"))
#'
filetype <- function(df,filetype_in="dataframe") {
if (tolower(filetype_in) == "dataframe") {data = df}  else if (tolower(filetype_in) == "rds") {
data = readRDS(df)}  else if (tolower(filetype_in) == "xls") {
data = read.xlsx(df, sheetName = 1, header = TRUE)}  else if (tolower(filetype_in) == "xlsx") {
data =  read.xlsx(df, sheetName = 1, header = TRUE)}  else if (tolower(filetype_in) == "csv") {
data = read.csv(df,header = TRUE, sep = ",")}  else stop("ERROR: File type is not compatible")
return(data)
}
res = split(df=data,filetype_in = "dataframe", seed=50, splitkey = NULL, stratifyby = c("rank","discipline"), trainprop=0.37)
View(data)
#' Partition data into train and test datasets.
#'
#' @param df A dataframe if filetype is dataframe or file path.
#' @param filetype Type of file read. Provide extension of file if not dataframe. Permissible filetypes are Rds, rds, csv, xls and xlsx.
#' @param seed Random seed value.
#' @param splitkey A key (variable) used to identify all records of the same entity (e.g.patient ID).
#' @param stratifyby A single column name or vector of column names that will be used to stratify data.
#' @param trainprop Proportion that should be retained in train dataset. Value ranges between 0 and 1. Default is 0.70.
#' @return Dataframes as train and test.
#' @examples
#' res = split(df=data,filetype = "dataframe", seed=50, splitkey = NULL, stratifyby = c("rank","discipline"), trainprop=0.70)
#' res = split(df=data, filetype = "dataframe",seed=50, splitkey = NULL, stratifyby = c("discipline"), trainprop=0.70)
#' res = split(df="/stats/projects/all/R_Tools_Development/data/salaries_data.xlsx", filetype = "xlsx",seed=50, splitkey = NULL, stratifyby = c("discipline"), trainprop=0.70)
#' res = split(df="/stats/projects/all/R_Tools_Development/data/salaries_data.csv", filetype = "csv", seed=50, splitkey = NULL, stratifyby = NULL,  trainprop=0.50)
#' res = split(df=data, filetype = "dataframe",seed=50, splitkey = "patient_id", stratifyby = c("rank"),  trainprop=0.50)
#' train <- res$train; test <- res$test
split <- function(df, filetype_in = "dataframe",seed=50, splitkey = NULL, stratifyby = NULL, trainprop=0.70) {
set.seed(seed)
data <- filetype(df=df,filetype_in=filetype_in)
#Check if splitkey has valid column name
if (!is.null(splitkey) & !(splitkey %in% colnames(data))) {stop("ERROR: splitkey is not a valid column name")}
#Check if trainprop is valid
if (trainprop > 1 | trainprop <0) {stop("ERROR: trainprop should be <= 1 and >= 0")}
#If unique ID is not required
if (is.null(splitkey)) {
# If stratified sampling is required
if (!is.null(stratifyby)){
list_t <- NULL
list_t <- data[[stratifyby[1]]]
if (length(stratifyby) > 1) {
for (i in 2: length(stratifyby)){
list_t <- list(list_t,data[[stratifyby[i]]])
}
}
sp <- base::split(seq_len(nrow(data)), list_t)
samples <- lapply(sp, function(x) sample(x, replace=F,size=trainprop*length(x)))
train <- data[unlist(samples), ]
test <- data[-unlist(samples),]
} else {
samples <- sample(1:dim(data)[1],replace=F,size=trainprop*dim(data)[1])
train <- data[samples,]
test <- data[-samples,]
}
} else {
unique_id <- unique(data[[splitkey]])
# If stratified sampling is required
if (!is.null(stratifyby)){
list_t <- NULL
list_t <- data[[stratifyby[1]]]
if (length(stratifyby) > 1) {
for (i in 2: length(stratifyby)){
list_t <- list(list_t,data[[stratifyby[i]]])
}
}
sp <- base::split(seq_len(nrow(data)), list_t)
samples <- lapply(sp, function(x) sample(x, replace=F,size=trainprop*length(x)))
samples <- unique_id[unlist(samples)]
train <- data[data[[splitkey]] %in% samples, ]
test <- data[!(data[[splitkey]] %in% samples),]
} else {
samples <- sample(1:dim(data)[1],replace=F,size=trainprop*dim(data)[1])
samples <- unique_id[samples]
train <- data[data[[splitkey]] %in% samples,]
test <- data[!(data[[splitkey]] %in% samples),]
}
}
split.data <- list()
split.data$train <- train
split.data$test <- test
#Check if result is produced correctly
if (dim(train)[1] == 0 | dim(test)[1] == 0) {
stop("ERROR: One or a combination of the following issues have occurred:
1. stratifyby is a numeric variable or has too many levels
2. trainprop in combination with stratifyby is too small to produce a valid data cut")}
return(split.data)
}
#Test
library(xlsx)
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
res = split(df=data,filetype_in = "dataframe", seed=50, splitkey = NULL, stratifyby = c("rank","discipline"), trainprop=0.37)
df=data
filetype_in = "dataframe"
set.seed(seed)
data <- filetype(df=df,filetype_in=filetype_in)
View(data)
#Check if splitkey has valid column name
if (!is.null(splitkey) & !(splitkey %in% colnames(data))) {stop("ERROR: splitkey is not a valid column name")}
splitkey = NULL
#Check if splitkey has valid column name
if (!is.null(splitkey) & !(splitkey %in% colnames(data))) {stop("ERROR: splitkey is not a valid column name")}
!is.null(splitkey)
splitkey
!(splitkey %in% colnames(data))
colnames(data)
#Check if splitkey has valid column name
if (!is.null(splitkey)) {
if (!(splitkey %in% colnames(data))) {stop("ERROR: splitkey is not a valid column name")}}
#' Partition data into train and test datasets.
#'
#' @param df A dataframe if filetype is dataframe or file path.
#' @param filetype Type of file read. Provide extension of file if not dataframe. Permissible filetypes are Rds, rds, csv, xls and xlsx.
#' @param seed Random seed value.
#' @param splitkey A key (variable) used to identify all records of the same entity (e.g.patient ID).
#' @param stratifyby A single column name or vector of column names that will be used to stratify data.
#' @param trainprop Proportion that should be retained in train dataset. Value ranges between 0 and 1. Default is 0.70.
#' @return Dataframes as train and test.
#' @examples
#' res = split(df=data,filetype = "dataframe", seed=50, splitkey = NULL, stratifyby = c("rank","discipline"), trainprop=0.70)
#' res = split(df=data, filetype = "dataframe",seed=50, splitkey = NULL, stratifyby = c("discipline"), trainprop=0.70)
#' res = split(df="/stats/projects/all/R_Tools_Development/data/salaries_data.xlsx", filetype = "xlsx",seed=50, splitkey = NULL, stratifyby = c("discipline"), trainprop=0.70)
#' res = split(df="/stats/projects/all/R_Tools_Development/data/salaries_data.csv", filetype = "csv", seed=50, splitkey = NULL, stratifyby = NULL,  trainprop=0.50)
#' res = split(df=data, filetype = "dataframe",seed=50, splitkey = "patient_id", stratifyby = c("rank"),  trainprop=0.50)
#' train <- res$train; test <- res$test
split <- function(df, filetype_in = "dataframe",seed=50, splitkey = NULL, stratifyby = NULL, trainprop=0.70) {
set.seed(seed)
data <- filetype(df=df,filetype_in=filetype_in)
#Check if splitkey has valid column name
if (!is.null(splitkey)) {
if (!(splitkey %in% colnames(data))) {stop("ERROR: splitkey is not a valid column name")}}
#Check if trainprop is valid
if (trainprop > 1 | trainprop <0) {stop("ERROR: trainprop should be <= 1 and >= 0")}
#If unique ID is not required
if (is.null(splitkey)) {
# If stratified sampling is required
if (!is.null(stratifyby)){
list_t <- NULL
list_t <- data[[stratifyby[1]]]
if (length(stratifyby) > 1) {
for (i in 2: length(stratifyby)){
list_t <- list(list_t,data[[stratifyby[i]]])
}
}
sp <- base::split(seq_len(nrow(data)), list_t)
samples <- lapply(sp, function(x) sample(x, replace=F,size=trainprop*length(x)))
train <- data[unlist(samples), ]
test <- data[-unlist(samples),]
} else {
samples <- sample(1:dim(data)[1],replace=F,size=trainprop*dim(data)[1])
train <- data[samples,]
test <- data[-samples,]
}
} else {
unique_id <- unique(data[[splitkey]])
# If stratified sampling is required
if (!is.null(stratifyby)){
list_t <- NULL
list_t <- data[[stratifyby[1]]]
if (length(stratifyby) > 1) {
for (i in 2: length(stratifyby)){
list_t <- list(list_t,data[[stratifyby[i]]])
}
}
sp <- base::split(seq_len(nrow(data)), list_t)
samples <- lapply(sp, function(x) sample(x, replace=F,size=trainprop*length(x)))
samples <- unique_id[unlist(samples)]
train <- data[data[[splitkey]] %in% samples, ]
test <- data[!(data[[splitkey]] %in% samples),]
} else {
samples <- sample(1:dim(data)[1],replace=F,size=trainprop*dim(data)[1])
samples <- unique_id[samples]
train <- data[data[[splitkey]] %in% samples,]
test <- data[!(data[[splitkey]] %in% samples),]
}
}
split.data <- list()
split.data$train <- train
split.data$test <- test
#Check if result is produced correctly
if (dim(train)[1] == 0 | dim(test)[1] == 0) {
stop("ERROR: One or a combination of the following issues have occurred:
1. stratifyby is a numeric variable or has too many levels
2. trainprop in combination with stratifyby is too small to produce a valid data cut")}
return(split.data)
}
#Test
library(xlsx)
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
res = split(df=data,filetype_in = "dataframe", seed=50, splitkey = NULL, stratifyby = c("rank","discipline"), trainprop=0.37)
res$train
dim(res$train)
dim(res$test)
.37*397
res = split(df="/stats/projects/all/R_Tools_Development/data/salaries_data.Rds", filetype_in = "Rds",seed=50, splitkey = NULL, stratifyby = c("discipline"), trainprop=0.70)
dim(res$train)
dim(res$test)
397*.7
res = split(df=data, filetype_in = "dataframe",seed=50, splitkey = NULL, stratifyby = NULL,  trainprop=0.50)
dim(res$train)
dim(res$test)
res = split(df=data, filetype_in = "dataframe",seed=50, splitkey = "patient_id", stratifyby = c("rank"),  trainprop=0.50)
dim(res$train)
dim(res$test)
id <- c(rep(1,10),rep(2,10),rep(3,10),rep(4,10),rep(5,10),rep(6,10),rep(7,30),8:314)
data$id <- id
res = split(df=data,filetype_in = "dataframe", seed=50, splitkey = "id", stratifyby = c("rank"),  trainprop=0.49)
dim(res$train)
dim(res$test)
res = split(df="/stats/projects/all/R_Tools_Development/data/salaries_data.xlsx", filetype_in = "xlsx",seed=50, splitkey = NULL, stratifyby = c("discipline"), trainprop=0.70)
res = split(df=data, filetype_in = "Rdata", seed=50, splitkey = NULL, stratifyby = NULL,  trainprop=0.50)
res = split(df=d,filetype_in = "dataframe", seed=50, splitkey = "atreyee", stratifyby = c("mpg_int"), trainprop=0.56)
res = split(df=data,filetype_in = "dataframe", seed=50, splitkey = "atreyee", stratifyby = c("mpg_int"), trainprop=0.56)
res = split(df=data,filetype_in = "dataframe", seed=50, splitkey = "atreyee", stratifyby = c("mpg_int"), trainprop=1.2)
res = split(df=data,filetype_in = "dataframe", seed=50, splitkey = "id", stratifyby = c("mpg_int"), trainprop=1.2)
listLearners("regr")
library(mlr)
listLearners("regr")
a = as.factor(c{"M","F"})
a = as.factor(c("M","F"))
a
is.factor(a)
a = (c("M","F"))
is.factor(a)
# R tool Development
# descriptive statistics
#############################################################################################################
#' Summary of Descriptive Statistics
#'
#' @param formula An object of class formula, describing how variables to be summarized.
#' @param df Input data for summary statistics, default is data frame. If data is not in data frame, please put your data path here
#' @param filetype_in Input file type, currently can accept data frame, rds, csv, xls, xlsx, default is data frame.
#' @param filetype_out Output type, currently can be rmd, rds, html and pdf, default is rmd.
#' @param output_path If output type is rds, html or pdf, please put your save path here.
#' @param to_numeric An optional input to change variable class to numeric
#' @param to_factor An optional input to change variable class to factor
#' @param level_droprange set the maximum level of a character variable that will be included in the summary table,
#' if a character variable's level exceeds this range, it will be automatically drop from the summary table, default value is 20.
#' @return Descriptive Summary Tables
#' @examples
#'
#' d_summary(sex ~ race + age, mockstudy)
#' d_summary(sex ~ race + age, mockstudy, cat.stats = "countrowpct")  # if you need to calculate row percentage
#' d_summary(sex ~., mockstudy, level_droprange = 5) # set level drop range rather than default
#' d_summary(sex ~ race + age, mockstudy, filetype_out = "rds", output_path = "/home/yyang/r_pack/r_test.Rds")
#' d_summary(sex ~ age + bmi + race, mockstudy, filetype_out = "pdf", output_path = "/home/yyang/r_pack/r_test.pdf")
#' d_summary(sex ~., mockstudy, filetype_out = "pdf", output_path = "/home/yyang/r_pack/r_test.pdf", level_droprange = 5)
d_summary <- function(formula, df, filetype_in = "dataframe", to_numeric = NULL, to_factor = NULL, level_droprange = 20,  filetype_out = "rmd", output_path = NULL, ...) {
if (tolower(filetype_in) == "dataframe") {data = df}  else if (tolower(filetype_in) == "rds") {
data = readRDS(df)}  else if (tolower(filetype_in) == "csv") {
data = read.csv(df, header = TRUE, sep = ",")}  else if (tolower(filetype_in) == "xls") {
data = read.xls(df, sheetName = 1, header = TRUE)}  else if (tolower(filetype_in) == "xlsx") {
data = read.xlsx(df, sheetName = 1, header = TRUE)}  else stop ("ERROR: Please select a valid file type")
library(arsenal)
library(tidyverse)
if (!is.null(to_numeric)) {
for(i in to_numeric ){
data[[i]] <- as.numeric(as.character(data[[i]]))
}
}
if (!is.null(to_factor)) {
for(i in to_factor){
data[[i]] <- as.factor(as.character(data[[i]]))
}
}
var_type_identify <- function (data,excludeVars=NULL) {
#Identify numeric variables
numVars <- NA
if (is.na(numVars[1])) {
for (i in 1:dim(data)[2]) {
yesnum <-  is.numeric(data[,i]) | is.integer(data[,i])
numVars <- append(numVars,ifelse(yesnum == "TRUE", colnames(data)[i],numVars),after = length(numVars))
}
}
numVars <- na.omit(numVars)
numVars <- numVars[!(numVars %in% excludeVars)]
#Identify character/categorical variables
categoricalVars <- NA
if (is.na(categoricalVars[1])) {
categoricalVars <- NA
for (i in 1:dim(data)[2]) {
yescat <-  is.character(data[,i]) | is.factor(data[,i])
categoricalVars <- append(categoricalVars,ifelse(yescat == "TRUE", colnames(data)[i],categoricalVars),after = length(categoricalVars))
}
}
categoricalVars <- na.omit(categoricalVars)
categoricalVars <- categoricalVars[!(categoricalVars %in% excludeVars)]
return(list(numVars,categoricalVars))
}
var_type_cf <- var_type_identify(data)[[2]]    # get character/factor variablie lists
if (!is.null(var_type_cf)) {
for(i in var_type_cf){
data[[i]] <- as.factor(as.character(data[[i]]))
}
}
if (! is.null(level_droprange)) {
l1 <- setDT(as.data.frame(sapply(data[,sapply(data, is.factor)], nlevels)), keep.rownames = TRUE)
names(l1)[2] <- "nlevels"
l2 <- subset(l1, l1$nlevels>level_droprange)
l3<-l2$rn   # drop list names
}
if (!purrr::is_empty(l3)) {data_a <- data[, -which(names(data) %in% l3)] # remove factor column which level exceed the setting range
}  else if (purrr::is_empty(l3)) {data_a <- data}  else stop ("ERROR: Please check level droprange")
f1 <- as.formula(formula)
tab1<-tableby(f1, data_a, ...)
tab1s<- summary(tab1, text = TRUE, ...)
if (tolower(filetype_out) == "rmd") {
tab1s %>%
as.data.frame() %>%
kable()     %>%
kable_styling(bootstrap_options = c("striped", "hover")) %>%
save_kable(file = "table1.html", self_contained = T)
# result<-tab2
}
else if (tolower(filetype_out) == "rds" & !is.null(output_path)){
tab2<-as.data.frame(tab1s)
tab2<-dplyr::rename(tab2, variables = "")
saveRDS(tab2,output_path)
}
else if (tolower(filetype_out) == "html" & !is.null(output_path) ){
write2html(tab1, output_path)
}
else if (tolower(filetype_out) == "pdf" & !is.null(output_path) ){
write2pdf(tab1, output_path)
}
else stop ("ERROR: Please check if filetype_out or output_path is missing/valid")
if (! purrr::is_empty(l3) & filetype_out == "rmd") {
message ("Warning: Variables shown below are dropped from summary since they exceed maximum level_droprange")
return((list(l3, browseURL("table1.html") )))
}
else if (! purrr::is_empty(l3) & filetype_out != "rmd") {
message ("Warning: Variables shown below are dropped from summary since they exceed maximum level_droprange")
return(l3)
}
else if (purrr::is_empty(l3) & filetype_out == "rmd") {
return(browseURL("table1.html") )
}
}
#Test
library(data.table)
library(kableExtra)
library(knitr)
d_summary(rank ~ ., data,level_droprange=3)
d_summary(rank ~ ., data,level_droprange=4,filetype_out = "pdf", output_path = "/stats/projects/all/R_Tools_Development/data/r_test.pdf")
d_summary(rank ~ ., data,level_droprange=4,filetype_out = "html", output_path = "/stats/projects/all/R_Tools_Development/data/r_test.html")
d_summary(rank ~ ., data,level_droprange=3)
d_summary(rank ~ ., data,level_droprange=3)
