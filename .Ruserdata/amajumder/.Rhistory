else stop("ERROR: Only minimum, maximum, mean, median and mode allowed for type of numeric variables imputation")
}
}
if (!is.null(factvarlist)) {
for(i in factvarlist ){
summ <- list()
if (tolower(type_fact) == "mode") {
summ[[i]] <- Mode(levels(data[[i]])[data[[i]]],na.rm=TRUE)
data[[i]] <- as.factor(ifelse(is.na(data[[i]]),summ[[i]],levels(data[[i]])[data[[i]]]))
}
else if (tolower(type_fact) == "missing") {
data[[i]] <- as.factor(ifelse(is.na(data[[i]]),"Missing",levels(data[[i]])[data[[i]]]))
}
else stop("ERROR: Only 'mode' and 'missing' allowed for type of factor variables imputation")
}
}
return(data)
}
#Test
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
View(data)
data[1,] <- c(NA,NA,NA,NA,NA,NA,0)
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "mode",round=2,factvarlist=c("rank"),type_fact="missing")
View(data_imputed)
impute <- function(data, numvarlist,type_num = "mean",round=0,factvarlist,type_fact = "missing") {
library(DescTools)
if (!is.null(numvarlist)) {
for(i in numvarlist ){
data[[i]] <- as.numeric(data[[i]])
summ <- list()
if (tolower(type_num) == "mean") {
summ[[i]] <- round(mean(data[[i]],na.rm=TRUE),round)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "median") {
summ[[i]] <- round(median(data[[i]],na.rm=TRUE),round)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "mode") {
summ[[i]] <- Mode(data[[i]],na.rm=TRUE,round)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "max") {
summ[[i]] <- max(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "min") {
summ[[i]] <- min(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else stop("ERROR: Only minimum, maximum, mean, median and mode allowed for type of numeric variables imputation")
}
}
if (!is.null(factvarlist)) {
for(i in factvarlist ){
summ <- list()
if (tolower(type_fact) == "mode") {
summ[[i]] <- Mode(levels(data[[i]])[data[[i]]],na.rm=TRUE)
data[[i]] <- as.factor(ifelse(is.na(data[[i]]),summ[[i]],levels(data[[i]])[data[[i]]]))
}
else if (tolower(type_fact) == "missing") {
data[[i]] <- as.factor(ifelse(is.na(data[[i]]),"Missing",levels(data[[i]])[data[[i]]]))
}
else stop("ERROR: Only 'mode' and 'missing' allowed for type of factor variables imputation")
}
}
return(data)
}
#Test
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
data[1,] <- c(NA,NA,NA,NA,NA,NA,0)
data$salary = as.integer(data$salary)
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "mode",round=2,factvarlist=c("rank"),type_fact="missing")
impute <- function(data, numvarlist,type_num = "mean",round=0,factvarlist,type_fact = "missing") {
library(DescTools)
if (!is.null(numvarlist)) {
for(i in numvarlist ){
data[[i]] <- as.numeric(data[[i]])
summ <- list()
if (tolower(type_num) == "mean") {
summ[[i]] <- round(mean(data[[i]],na.rm=TRUE),round)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "median") {
summ[[i]] <- round(median(data[[i]],na.rm=TRUE),round)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "mode") {
summ[[i]] <- Mode(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "max") {
summ[[i]] <- max(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "min") {
summ[[i]] <- min(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else stop("ERROR: Only minimum, maximum, mean, median and mode allowed for type of numeric variables imputation")
}
}
if (!is.null(factvarlist)) {
for(i in factvarlist ){
summ <- list()
if (tolower(type_fact) == "mode") {
summ[[i]] <- Mode(levels(data[[i]])[data[[i]]],na.rm=TRUE)
data[[i]] <- as.factor(ifelse(is.na(data[[i]]),summ[[i]],levels(data[[i]])[data[[i]]]))
}
else if (tolower(type_fact) == "missing") {
data[[i]] <- as.factor(ifelse(is.na(data[[i]]),"Missing",levels(data[[i]])[data[[i]]]))
}
else stop("ERROR: Only 'mode' and 'missing' allowed for type of factor variables imputation")
}
}
return(data)
}
#Test
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
data[1,] <- c(NA,NA,NA,NA,NA,NA,0)
data$salary = as.integer(data$salary)
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "mode",round=2,factvarlist=c("rank"),type_fact="missing")
table(salary)
table(data$salary)
a =c(1,1,2,2)
Mode(a)
min(Mode(a))
max(Mode(a))
a =c(1,1,2,2,3,3)
Mode(a)
table(a)
max(table(a))
a = c(1,2,2)
Mode(a)
table(a)
max(table(a))
a = c(1,3,3)
Mode(a)
max(table(a))
table(a)
a = c(1,3,3,3)
max(table(a))
which.max(table(a))
table(a)
which.max(table(a))
a = c(1,2,3,3,3)
which.max(table(a))
t = which.max(table(a))
t
str(t)
a = c(1,2,3,3,3,22,22,22,22,22)
table(a)
which.max(table((a)))
names(which.max(table((a))))
a = c(1,2,3,3,3,3,3,22,22,22,22,22)
which.max(table((a)))
Mode(a)
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "min",round=2,factvarlist=c("rank"),type_fact="missing")
View(data_imputed)
min(data$salary)
min(data$salary,na.rm+TRUE)
min(data$salary,na.rm=TRUE)
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "max",round=2,factvarlist=c("rank"),type_fact="missing")
max(data$salary,na.rm=TRUE)
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "max",round=2,factvarlist=c("rank"),type_fact="mode")
table(data$rank)
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "maximum",round=2,factvarlist=c("rank"),type_fact="mode")
#' Imputation of missing values.
#'
#' @param data A dataframe.
#' @param numvarlist A vector of numeric variables to be imputed.
#' @param type_num Type of imputation for numeric variables to be used. Mean is Default method. Choices are min, max, mean, median and mode.
#' @param round Upto which decimal should imputed numeric values be rounded. Default rounds to whole number.
#' @param factvarlist A vector of factor variables to be imputed.
#' @param type_fact Type of imputation for factor variables to be used. Add 'missing' level is Default method. Choices are mode and missing.
#' @return Input dataset with imputed values.
#' @examples
#' data <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "mean",round=0,factvarlist=c("rank"),type_fact = "mode")
#' data <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "median",round=2,factvarlist=c("rank"),type_fact="missing")
#'
impute <- function(data, numvarlist,type_num = "mean",round=0,factvarlist,type_fact = "missing") {
library(DescTools)
if (!is.null(numvarlist)) {
for(i in numvarlist ){
data[[i]] <- as.numeric(data[[i]])
summ <- list()
if (tolower(type_num) == "mean") {
summ[[i]] <- round(mean(data[[i]],na.rm=TRUE),round)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "median") {
summ[[i]] <- round(median(data[[i]],na.rm=TRUE),round)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "mode") {
summ[[i]] <- Mode(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "max") {
summ[[i]] <- max(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "min") {
summ[[i]] <- min(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else stop("ERROR: Only min, max, mean, median and mode allowed for type of numeric variables imputation")
}
}
if (!is.null(factvarlist)) {
for(i in factvarlist ){
summ <- list()
if (tolower(type_fact) == "mode") {
summ[[i]] <- Mode(levels(data[[i]])[data[[i]]],na.rm=TRUE)
data[[i]] <- as.factor(ifelse(is.na(data[[i]]),summ[[i]],levels(data[[i]])[data[[i]]]))
}
else if (tolower(type_fact) == "missing") {
data[[i]] <- as.factor(ifelse(is.na(data[[i]]),"Missing",levels(data[[i]])[data[[i]]]))
}
else stop("ERROR: Only 'mode' and 'missing' allowed for type of factor variables imputation")
}
}
return(data)
}
#Test
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
data[1,] <- c(NA,NA,NA,NA,NA,NA,0)
data$salary = as.integer(data$salary)
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "max",round=2,factvarlist=c("rank"),type_fact="mode")
str(data_imputed$rank)
levels(data_imputed$rank)
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "max",round=2,factvarlist=c("rank"),type_fact="missing")
levels(data_imputed$rank)
table(data_imputed$rank)
table(data$rank)
View(data)
265+67+64
+1
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "max",round=2,factvarlist=c("rank"),type_fact="mode")
table(data_imputed$rank)
multicoll_chk(data=data,excludeVars=NULL,outtype="xls",outpath="/stats/projects/all/R_Tools_Development/data/multicoll_chk.xls")
multicoll_chk(data=data,excludeVars=NULL,outtype="xls",outpath="/stats/projects/all/R_Tools_Development/data/multicoll_chk.xls")
multicoll_chk(data=data,excludeVars=NULL,outtype="xls",
outpath="/stats/projects/all/R_Tools_Development/data/multicoll_chk.xls")
#' Check for Multicollinearity among candidate predictors.
#'
#' @param data A dataframe.
#' @param excludeVars A vector of variables to be excluded form multicollinearity check.
#' @param numVars A vector of numeric variables (optional).
#' @param categoricalVars A vector of character (categorical) variables (optional).
#' @param cutoff Cutoff of correlation coefficient or Cramer's V coefficient to be used to output correlated variables.
#' @param corrmethod Correlation coefficient method to be used, Default is 'pearson'. Options are 'kendall', 'spearman'.
#' @param outtype Type of output file.
#' @param outpath Path of output file if xls or xlsx outtype selected.
#' @return A list of 2 dataframes; correlation analysis of numeric variables are stored as list1 and categorical analysis is stored as list2.
#' @examples
#' multi_out <- multicoll_chk(data=data,numVars=c("yrs.service","yrs.since.phd"),categoricalVars = c("rank","discipline"))
#' multi_out <- multicoll_chk(data=data)
#' multi_out <- multicoll_chk(data=data,excludeVars="patient_id")
#' multi_out <- multicoll_chk(data=data,excludeVars=NULL,outtype="xls",outpath="/stats/projects/all/R_Tools_Development/data/multicoll_chk.xls")
multicoll_chk <- function(data,excludeVars=NULL,numVars=NULL,categoricalVars=NULL,cutoff=0,corrmethod="pearson",outtype="list",outpath) {
#Identify numeric variables if is.null(numVars)
if (is.null(numVars)) {
numVars <- NA
}
if (is.na(numVars[1])) {
for (i in 1:dim(data)[2]) {
yesnum <-  is.numeric(data[,i])
numVars <- append(numVars,ifelse(yesnum == "TRUE", colnames(data)[i],numVars),after = length(numVars))
}
}
numVars <- na.omit(numVars)
numVars <- numVars[!(numVars %in% excludeVars)]
#Identify character/categorical variables if is.null(categoricalVars)
if (is.null(categoricalVars)) {
categoricalVars <- NA
}
if (is.na(categoricalVars[1])) {
categoricalVars <- NA
for (i in 1:dim(data)[2]) {
yescat <-  is.character(data[,i]) | is.factor(data[,i])
categoricalVars <- append(categoricalVars,ifelse(yescat == "TRUE", colnames(data)[i],categoricalVars),after = length(categoricalVars))
}
}
categoricalVars <- na.omit(categoricalVars)
categoricalVars <- categoricalVars[!(categoricalVars %in% excludeVars)]
#Correlation for categorical variables
library(pedometrics)
if (is.null(categoricalVars)) {
message("No numeric variables in dataset")
}  else {    cramer_d <- data[,which(colnames(data) %in% categoricalVars)]}
if (length(cramer_d) > 0 ) {
cramer_vars <- matrix(0,((dim(cramer_d)[2]*(dim(cramer_d)[2]-1))/2),3)
cramer_v <- cramer(cramer_d)
c=0
for (j in 1:dim(cramer_v)[2]) {
if ((j+1) <= dim(cramer_v)[2]) {for (k in (j+1):dim(cramer_v)[2]) {
c=c+1
cramer_vars[c,1] <- rownames(cramer_v)[j]
cramer_vars[c,2] <- colnames(cramer_v)[k]
cramer_vars[c,3] <- cramer_v[j,k]
}
}
}
cramer_vars <- data.frame(cramer_vars)
colnames(cramer_vars) <- c("Variable1", "Variable2", "Coeff")
cramer_vars$Coeff <- as.numeric(as.character(cramer_vars$Coeff))
#Track the variables that are highly correlated
corr_categorical <- cramer_vars[cramer_vars[["Coeff"]] >= cutoff,]
}
#Correlation for numeric variables
if (is.null(numVars)) {
message("No numeric variables in dataset")
} else {corr_d <- data[,which(colnames(data) %in% numVars)]}
if (length(corr_d) > 0 ) {
corr_vars <- matrix(0,((dim(corr_d)[2]*(dim(corr_d)[2]-1))/2),3)
corr_v <- cor(corr_d, use="complete.obs", method=corrmethod)
c=0
for (j in 1:dim(corr_v)[2]) {
if ((j+1) <= dim(corr_v)[2]) {for (k in (j+1):dim(corr_v)[2]) {
c=c+1
corr_vars[c,1] <- rownames(corr_v)[j]
corr_vars[c,2] <- colnames(corr_v)[k]
corr_vars[c,3] <- corr_v[j,k]
}
}
}
corr_vars <- data.frame(corr_vars)
colnames(corr_vars) <- c("Variable1", "Variable2", "Coeff")
corr_vars$Coeff <- as.numeric(as.character(corr_vars$Coeff))
#Track the variables that are highly correlated
corr_num <- corr_vars[corr_vars[["Coeff"]] >= cutoff,]
}
if (outtype == "list"){
corr_list <- list()
corr_list$numeric_list <- corr_num
corr_list$categorical_list <- corr_categorical
return(corr_list)
} else if (tolower(outtype) == "xls" | tolower(outtype) == "xlsx") {
write.xlsx(corr_num, file=outpath, sheetName="Numeric List", row.names=FALSE)
write.xlsx(corr_categorical, file=outpath, sheetName="Categorical List", append=TRUE, row.names=FALSE)
} else stop("ERROR: Type of output file should either be list, xls or xlsx")
}
#Test
library(xlsx)
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
a = multicoll_chk(data=data,numVars=c("yrs.service","yrs.since.phd"),categoricalVars = c("rank","discipline"))
a
a = multicoll_chk(data=data,excludeVars="patient_id")
a
#' Imputation of missing values.
#'
#' @param data A dataframe.
#' @param numvarlist A vector of numeric variables to be imputed.
#' @param type_num Type of imputation for numeric variables to be used. Mean is Default method. Choices are min, max, mean, median and mode.
#' @param round Upto which decimal should imputed numeric values be rounded. Default rounds to whole number.
#' @param factvarlist A vector of factor variables to be imputed.
#' @param type_fact Type of imputation for factor variables to be used. Add 'missing' level is Default method. Choices are mode and missing.
#' @return Input dataset with imputed values.
#' @examples
#' data <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "mean",round=0,factvarlist=c("rank"),type_fact = "mode")
#' data <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "median",round=2,factvarlist=c("rank"),type_fact="missing")
#'
impute <- function(data, numvarlist,type_num = "mean",round=0,factvarlist,type_fact = "missing") {
library(DescTools)
if (!is.null(numvarlist)) {
for(i in numvarlist ){
data[[i]] <- as.numeric(data[[i]])
summ <- list()
if (tolower(type_num) == "mean") {
summ[[i]] <- round(mean(data[[i]],na.rm=TRUE),round)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "median") {
summ[[i]] <- round(median(data[[i]],na.rm=TRUE),round)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "mode") {
summ[[i]] <- Mode(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "max") {
summ[[i]] <- max(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else if (tolower(type_num) == "min") {
summ[[i]] <- min(data[[i]],na.rm=TRUE)
data[[i]] <- ifelse(is.na(data[[i]]),summ[[i]],data[[i]])
}
else stop("ERROR: Only min, max, mean, median and mode allowed for type of numeric variables imputation")
}
}
if (!is.null(factvarlist)) {
for(i in factvarlist ){
summ <- list()
if (tolower(type_fact) == "mode") {
summ[[i]] <- Mode(levels(data[[i]])[data[[i]]],na.rm=TRUE)
data[[i]] <- as.factor(ifelse(is.na(data[[i]]),summ[[i]],levels(data[[i]])[data[[i]]]))
}
else if (tolower(type_fact) == "missing") {
data[[i]] <- as.factor(ifelse(is.na(data[[i]]),"Missing",levels(data[[i]])[data[[i]]]))
}
else stop("ERROR: Only 'mode' and 'missing' allowed for type of factor variables imputation")
}
}
return(data)
}
#Test
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
data[1,] <- c(NA,NA,NA,NA,NA,NA,0)
data$salary = as.integer(data$salary)
data_imputed <- impute(data=data,numvarlist=c("salary","yrs.service"),type_num = "max",round=2,factvarlist=c("rank"),type_fact="missing")
View(data_imputed)
a = multicoll_chk(data=data,excludeVars="patient_id")
a = multicoll_chk(data=data,numVars=c("yrs.service","yrs.since.phd"),categoricalVars = c("rank","discipline"))
a
a = multicoll_chk(data=data,excludeVars="patient_id")
a
#' Partition data into train and test datasets.
#'
#' @param data A dataframe if filetype is dataframe or file path.
#' @param filetype Type of file read. Provide extension of file if not dataframe. Permissible filetypes are Rds, rds, csv, xls and xlsx.
#' @param seed Random seed value.
#' @param splitkey A key (variable) used to identify all records of the same entity (e.g.patient ID).
#' @param stratifyby A single column name or vector of column names that will be used to stratify data.
#' @param trainprop Proportion that should be retained in train dataset. Value ranges between 0 and 1. Default is 0.70.
#' @return Dataframes as train and test.
#' @examples
#' res = split(data=data,filetype = "dataframe", seed=50, splitkey = NULL, stratifyby = c("rank","discipline"), trainprop=0.70)
#' res = split(data=data, filetype = "dataframe",seed=50, splitkey = NULL, stratifyby = c("discipline"), trainprop=0.70)
#' res = split(data="/stats/projects/all/R_Tools_Development/data/salaries_data.xlsx", filetype = "xlsx",seed=50, splitkey = NULL, stratifyby = c("discipline"), trainprop=0.70)
#' res = split(data="/stats/projects/all/R_Tools_Development/data/salaries_data.csv", filetype = "csv", seed=50, splitkey = NULL, stratifyby = NULL,  trainprop=0.50)
#' res = split(data=data, filetype = "dataframe",seed=50, splitkey = "patient_id", stratifyby = c("rank"),  trainprop=0.50)
#' train <- res$train; test <- res$test
split <- function(data, filetype = "dataframe",seed=50, splitkey = NULL, stratifyby = NULL, trainprop=0.70) {
set.seed(seed)
if (tolower(filetype) == "dataframe") {data = data}
else if (tolower(filetype) == "rds") {data = readRDS(data)}
else if (tolower(filetype) == "xls") {data = read.xlsx(data, sheetName = 1, header = TRUE)}
else if (tolower(filetype) == "xlsx") {data =  read.xlsx(data, sheetName = 1, header = TRUE)}
else if (tolower(filetype) == "csv") {data = read.csv(data,header = TRUE, sep = ",")}
else stop("ERROR: File type is not compatible")
#If unique ID is not required
if (is.null(splitkey)) {
# If stratified sampling is required
if (!is.null(stratifyby)){
list_t <- NULL
list_t <- data[[stratifyby[1]]]
if (length(stratifyby) > 1) {
for (i in 2: length(stratifyby)){
list_t <- list(list_t,data[[stratifyby[i]]])
}
}
sp <- base::split(seq_len(nrow(data)), list_t)
samples <- lapply(sp, function(x) sample(x, replace=F,size=trainprop*length(x)))
train <- data[unlist(samples), ]
test <- data[-unlist(samples),]
} else {
samples <- sample(1:dim(data)[1],replace=F,size=trainprop*dim(data)[1])
train <- data[samples,]
test <- data[-samples,]
}
} else {
unique_id <- unique(data[[splitkey]])
# If stratified sampling is required
if (!is.null(stratifyby)){
list_t <- NULL
list_t <- data[[stratifyby[1]]]
if (length(stratifyby) > 1) {
for (i in 2: length(stratifyby)){
list_t <- list(list_t,data[[stratifyby[i]]])
}
}
sp <- base::split(seq_len(nrow(data)), list_t)
samples <- lapply(sp, function(x) sample(x, replace=F,size=trainprop*length(x)))
samples <- unique_id[unlist(samples)]
train <- data[data[[splitkey]] %in% samples, ]
test <- data[!(data[[splitkey]] %in% samples),]
} else {
samples <- sample(1:dim(data)[1],replace=F,size=trainprop*dim(data)[1])
samples <- unique_id[samples]
train <- data[data[[splitkey]] %in% samples,]
test <- data[!(data[[splitkey]] %in% samples),]
}
}
split.data <- list()
split.data$train <- train
split.data$test <- test
return(split.data)
}
#Test
library(xlsx)
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
res = split(data=data,filetype = "dataframe", seed=50, splitkey = "id", stratifyby = c("rank"),  trainprop=0.50)
res
View(data)
library(xlsx)
data = readRDS("/stats/projects/all/R_Tools_Development/data/salaries_data.Rds")
id <- c(rep(1,10),rep(2,10),rep(3,10),rep(4,10),rep(5,10),rep(6,10),rep(7,30),8:314)
data$id <- id
res = split(data=data,filetype = "dataframe", seed=50, splitkey = "id", stratifyby = c("rank"),  trainprop=0.50)
res
res = split(data=data, filetype = "dataframe",seed=50, splitkey = "patient_id", stratifyby = c("rank"),  trainprop=0.50)
res
str(res)
class(res)
dim(strtrain)
class(res)
dim(res$train)
dim(res$test)
which(res$train[["patient_id"]] %in% res$test[["patient_id"]])
which(res$train[["patient_id"]] %in% res$train[["patient_id"]])
