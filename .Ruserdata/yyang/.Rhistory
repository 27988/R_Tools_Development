plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
sens.ci <- ci.se(pROC_obj)
plot(sens.ci, type="shape", col="lightblue")
plot(sens.ci, type="bars")
}
df_pred<-as.numeric(df_pred)
df_true<-as.numeric(df_true)
if (eval_metric == "confusion matrix") {
cm<- caret::confusionMatrix(as.factor(df_pred), as.factor(df_true)) #The functions requires that the factors have exactly the same levels
res<-cm
}
else if (eval_metric == "logloss") {
ll<- Metrics::logLoss(df_true, df_pred) #computes the average log loss between two numeric vectors
res<-ll
}
else if (eval_metric == "roc") {
roc<- roc_plot(df_pred, df_true)
res<-roc
}
else if (eval_metric == "rmse") {
rmse<- Metrics::rmse(df_true, df_pred)
res<-rmse
}
else if (eval_metric == "mae") {
mae<- Metrics::mae(df_true, df_pred)
res<-mae
}
else if (eval_metric == "rsqure"){
r2<- rsq(df_pred, df_true)
res<-r2
}
else if (eval_metric == "quantile plot" & !is.null(bin)){
qt <- data.frame( response = df_pred,  actual= df_true) %>%
arrange(response) %>%
mutate(bin_value = ntile(response, bin)) %>%
group_by(bin_value) %>%
summarise(sum_actual= mean(actual), sum_pred = mean(response), .groups = 'drop')
qt<-as.data.frame(qt)
qt1<-qt[,c(1,2)]
qt1$Group <- rep("Actual", nrow(qt1))
colnames(qt1)[2] <- "Value"
qt2<-qt[,c(1,3)]
qt2$Group <- rep("Predict", nrow(qt2))
colnames(qt2)[2] <- "Value"
qt<-rbind(qt1, qt2)
res = ggplot(data=qt,
aes(x=bin_value, y=Value, colour= Group)) +
geom_line() + labs(title="Quantile Plot", x ="Bin", y = "Value") +
theme_bw()
}
else stop ("ERROR: Please select vaild evaluation matrix")
return(res)
}
eval_fun(xtab$pred, xtab$truth, eval_metric = "quantile plot")
#Test
eval_fun(xtab$pred, xtab$truth, eval_metric = "confusion matrix")
mean(1)
> data(cars)
> comment(cars) <- "Example Data"
> comment(cars)
data(cars)
comment(cars) <- "Example Data"
comment(cars)
cars
eval_fun(xtab$pred, xtab$truth, eval_metric = "rsqure))
qt <- data.frame(response = as.numeric(xtab$pred),  actual= as.numeric(xtab$truth)) %>%
arrange(response) %>%
mutate(bin_value = ntile(response, 10)) %>%
group_by(bin_value) %>%
summarise(sum_actual= mean(actual), sum_pred = mean(response), .groups = 'drop')
qt<-as.data.frame(qt)
qt1<-qt[,c(1,2)]
qt1$Group <- rep("Actual", nrow(qt1))
colnames(qt1)[2] <- "Value"
qt2<-qt[,c(1,3)]
qt2$Group <- rep("Predict", nrow(qt2))
colnames(qt2)[2] <- "Value"
qt<-rbind(qt1, qt2)
p = ggplot(data=qt,
aes(x=bin_value, y=Value, colour= Group)) +
geom_line() + labs(title="Quantile Plot", x ="Bin", y = "Value") +
theme_bw()
eval_fun(xtab$pred, xtab$truth, eval_metric = "rsqure")
eval_fun <- function(df_pred, df_true, threshold = FALSE, threshold_value = NULL, eval_metric, bin = 10){
require(caret)
require(pROC)
require(Metrics)
require(ggplot2)
#get predicted class based on probability values
if (threshold == TRUE & !is.null(threshold)){
df_pred<-ifelse(df_pred >= threshold_value, 1, 0)
}
df_pred<-as.numeric(df_pred)
df_true<-as.numeric(df_true)
#get R2
rsq<-function(df_pred, df_true){
(1- sum((df_pred - df_true) ^ 2)/sum((df_true - mean(df_true))^2))
}
#get ROC PLOT
roc_plot<- function(df_pred, df_true){
pROC_obj <- roc(df_true, df_pred,
smoothed = TRUE,
# arguments for ci
ci=TRUE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
sens.ci <- ci.se(pROC_obj)
plot(sens.ci, type="shape", col="lightblue")
plot(sens.ci, type="bars")
}
if (eval_metric == "confusion matrix") {
cm<- caret::confusionMatrix(as.factor(df_pred), as.factor(df_true)) #The functions requires that the factors have exactly the same levels
res<-cm
}
else if (eval_metric == "logloss") {
ll<- Metrics::logLoss(df_true, df_pred) #computes the average log loss between two numeric vectors
res<-ll
}
else if (eval_metric == "roc") {
roc<- roc_plot(df_pred, df_true)
res<-roc
}
else if (eval_metric == "rmse") {
rmse<- Metrics::rmse(df_true, df_pred)
res<-rmse
}
else if (eval_metric == "mae") {
mae<- Metrics::mae(df_true, df_pred)
res<-mae
}
else if (eval_metric == "rsqure"){
r2<- rsq(df_pred, df_true)
res<-r2
}
else if (eval_metric == "quantile plot" & !is.null(bin)){
qt <- data.frame( response = df_pred,  actual= df_true) %>%
arrange(response) %>%
mutate(bin_value = ntile(response, bin)) %>%
group_by(bin_value) %>%
summarise(sum_actual= mean(actual), sum_pred = mean(response), .groups = 'drop')
qt<-as.data.frame(qt)
qt1<-qt[,c(1,2)]
qt1$Group <- rep("Actual", nrow(qt1))
colnames(qt1)[2] <- "Value"
qt2<-qt[,c(1,3)]
qt2$Group <- rep("Predict", nrow(qt2))
colnames(qt2)[2] <- "Value"
qt<-rbind(qt1, qt2)
res = ggplot(data=qt,
aes(x=bin_value, y=Value, colour= Group)) +
geom_line() + labs(title="Quantile Plot", x ="Bin", y = "Value") +
theme_bw()
}
else if (eval_metric == "brier"){
res <- list()
res[[1]] <- "Brier Score"
res[[2]] <-mean((df_pred- df_true)^2)
}
else stop ("ERROR: Please select vaild evaluation matrix")
return(res)
}
eval_fun(xtab$pred, xtab$truth, eval_metric = "brier")
eval_fun(xtab$pred, xtab$truth, eval_metric = "mae")
eval_fun <- function(df_pred, df_true, threshold = FALSE, threshold_value = NULL, eval_metric, bin = 10){
require(caret)
require(pROC)
require(Metrics)
require(ggplot2)
#get predicted class based on probability values
if (threshold == TRUE & !is.null(threshold)){
df_pred<-ifelse(df_pred >= threshold_value, 1, 0)
}
df_pred<-as.numeric(df_pred)
df_true<-as.numeric(df_true)
#get R2
rsq<-function(df_pred, df_true){
(1- sum((df_pred - df_true) ^ 2)/sum((df_true - mean(df_true))^2))
}
#get ROC PLOT
roc_plot<- function(df_pred, df_true){
pROC_obj <- roc(df_true, df_pred,
smoothed = TRUE,
# arguments for ci
ci=TRUE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
sens.ci <- ci.se(pROC_obj)
plot(sens.ci, type="shape", col="lightblue")
plot(sens.ci, type="bars")
}
if (eval_metric == "confusion matrix") {
cm<- caret::confusionMatrix(as.factor(df_pred), as.factor(df_true)) #The functions requires that the factors have exactly the same levels
res<-cm
}
else if (eval_metric == "logloss") {
ll<- Metrics::logLoss(df_true, df_pred) #computes the average log loss between two numeric vectors
res<-ll
}
else if (eval_metric == "roc") {
roc<- roc_plot(df_pred, df_true)
res<-roc
}
else if (eval_metric == "rmse") {
rmse<- Metrics::rmse(df_true, df_pred)
res<-rmse
}
else if (eval_metric == "mae") {
mae<- Metrics::mae(df_true, df_pred)
res<-mae
}
else if (eval_metric == "rsqure"){
res <- list()
res[[1]] <- "R-Squre"
res[[2]] <- rsq(df_pred, df_true)
}
else if (eval_metric == "quantile plot" & !is.null(bin)){
qt <- data.frame( response = df_pred,  actual= df_true) %>%
arrange(response) %>%
mutate(bin_value = ntile(response, bin)) %>%
group_by(bin_value) %>%
summarise(sum_actual= mean(actual), sum_pred = mean(response), .groups = 'drop')
qt<-as.data.frame(qt)
qt1<-qt[,c(1,2)]
qt1$Group <- rep("Actual", nrow(qt1))
colnames(qt1)[2] <- "Value"
qt2<-qt[,c(1,3)]
qt2$Group <- rep("Predict", nrow(qt2))
colnames(qt2)[2] <- "Value"
qt<-rbind(qt1, qt2)
res = ggplot(data=qt,
aes(x=bin_value, y=Value, colour= Group)) +
geom_line() + labs(title="Quantile Plot", x ="Bin", y = "Value") +
theme_bw()
}
else if (eval_metric == "brier"){
res <- list()
res[[1]] <- "Brier Score"
res[[2]] <-mean((df_pred- df_true)^2)
}
else stop ("ERROR: Please select vaild evaluation matrix")
return(res)
}
eval_fun(xtab$pred, xtab$truth, eval_metric = "rsqure")
eval_fun <- function(df_pred, df_true, threshold = FALSE, threshold_value = NULL, eval_metric, bin = 10){
require(caret)
require(pROC)
require(Metrics)
require(ggplot2)
#get predicted class based on probability values
if (threshold == TRUE & !is.null(threshold)){
df_pred<-ifelse(df_pred >= threshold_value, 1, 0)
}
df_pred<-as.numeric(df_pred)
df_true<-as.numeric(df_true)
#get R2
rsq<-function(df_pred, df_true){
(1- sum((df_pred - df_true) ^ 2)/sum((df_true - mean(df_true))^2))
}
#get ROC PLOT
roc_plot<- function(df_pred, df_true){
pROC_obj <- roc(df_true, df_pred,
smoothed = TRUE,
# arguments for ci
ci=TRUE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
sens.ci <- ci.se(pROC_obj)
plot(sens.ci, type="shape", col="lightblue")
plot(sens.ci, type="bars")
}
if (eval_metric == "confusion matrix") {
cm<- caret::confusionMatrix(as.factor(df_pred), as.factor(df_true)) #The functions requires that the factors have exactly the same levels
res<-cm
}
else if (eval_metric == "logloss") {
ll<- Metrics::logLoss(df_true, df_pred) #computes the average log loss between two numeric vectors
res<-ll
}
else if (eval_metric == "roc") {
roc<- roc_plot(df_pred, df_true)
res<-roc
}
else if (eval_metric == "rmse") {
rmse<- Metrics::rmse(df_true, df_pred)
res<-rmse
}
else if (eval_metric == "mae") {
mae<- Metrics::mae(df_true, df_pred)
res<-mae
}
else if (eval_metric == "rsqure"){
r2<- rsq(df_pred, df_true)
res<-r2
}
else if (eval_metric == "quantile plot" & !is.null(bin)){
qt <- data.frame( response = df_pred,  actual= df_true) %>%
arrange(response) %>%
mutate(bin_value = ntile(response, bin)) %>%
group_by(bin_value) %>%
summarise(sum_actual= mean(actual), sum_pred = mean(response), .groups = 'drop')
qt<-as.data.frame(qt)
qt1<-qt[,c(1,2)]
qt1$Group <- rep("Actual", nrow(qt1))
colnames(qt1)[2] <- "Value"
qt2<-qt[,c(1,3)]
qt2$Group <- rep("Predict", nrow(qt2))
colnames(qt2)[2] <- "Value"
qt<-rbind(qt1, qt2)
res = ggplot(data=qt,
aes(x=bin_value, y=Value, colour= Group)) +
geom_line() + labs(title="Quantile Plot", x ="Bin", y = "Value") +
theme_bw()
}
else if (eval_metric == "brier"){
#res <- list()
#res[[1]] <- "Brier Score"
#res[[2]] <-mean((df_pred- df_true)^2)
res <-mean((df_pred- df_true)^2)
}
else stop ("ERROR: Please select vaild evaluation matrix")
return(res)
}
eval_fun(xtab$pred, xtab$truth, eval_metric = "brier")
#Test
eval_fun(xtab$pred, xtab$truth, eval_metric = "confusion matrix")
fg<-rnorm(300)
bg<-rnorm(500,-2)
fg
bg
eval_fun <- function(df_pred, df_true, threshold = FALSE, threshold_value = NULL, eval_metric, bin = 10){
require(caret)
require(pROC)
require(Metrics)
require(ggplot2)
#get predicted class based on probability values
if (threshold == TRUE & !is.null(threshold)){
df_pred<-ifelse(df_pred >= threshold_value, 1, 0)
}
df_pred<-as.numeric(df_pred)
df_true<-as.numeric(df_true)
#get R2
rsq<-function(df_pred, df_true){
(1- sum((df_pred - df_true) ^ 2)/sum((df_true - mean(df_true))^2))
}
#get ROC PLOT
roc_plot<- function(df_pred, df_true){
pROC_obj <- roc(df_true, df_pred,
smoothed = TRUE,
# arguments for ci
ci=TRUE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
sens.ci <- ci.se(pROC_obj)
plot(sens.ci, type="shape", col="lightblue")
plot(sens.ci, type="bars")
}
if (eval_metric == "confusion matrix") {
cm<- caret::confusionMatrix(as.factor(df_pred), as.factor(df_true)) #The functions requires that the factors have exactly the same levels
res<-cm
}
else if (eval_metric == "logloss") {
ll<- Metrics::logLoss(df_true, df_pred) #computes the average log loss between two numeric vectors
res<-ll
}
else if (eval_metric == "roc") {
roc<- roc_plot(df_pred, df_true)
res<-roc
}
else if (eval_metric == "rmse") {
rmse<- Metrics::rmse(df_true, df_pred)
res<-rmse
}
else if (eval_metric == "mae") {
mae<- Metrics::mae(df_true, df_pred)
res<-mae
}
else if (eval_metric == "rsqure"){
r2<- rsq(df_pred, df_true)
res<-r2
}
else if (eval_metric == "quantile plot" & !is.null(bin)){
qt <- data.frame( response = df_pred,  actual= df_true) %>%
arrange(response) %>%
mutate(bin_value = ntile(response, bin)) %>%
group_by(bin_value) %>%
summarise(sum_actual= mean(actual), sum_pred = mean(response), .groups = 'drop')
qt<-as.data.frame(qt)
qt1<-qt[,c(1,2)]
qt1$Group <- rep("Actual", nrow(qt1))
colnames(qt1)[2] <- "Value"
qt2<-qt[,c(1,3)]
qt2$Group <- rep("Predict", nrow(qt2))
colnames(qt2)[2] <- "Value"
qt<-rbind(qt1, qt2)
res = ggplot(data=qt,
aes(x=bin_value, y=Value, colour= Group)) +
geom_line() + labs(title="Quantile Plot", x ="Bin", y = "Value") +
theme_bw()
}
else if (eval_metric == "brier"){
#res <- list()
#res[[1]] <- "Brier Score"
#res[[2]] <-mean((df_pred- df_true)^2)
res <-mean((df_pred- df_true)^2)
}
else stop ("ERROR: Please select vaild evaluation matrix")
return(res)
}
eval_fun(xtab$pred, xtab$truth, eval_metric = "quantile")
eval_fun <- function(df_pred, df_true, threshold = FALSE, threshold_value = NULL, eval_metric, bin = 10){
require(caret)
require(pROC)
require(Metrics)
require(ggplot2)
#get predicted class based on probability values
if (threshold == TRUE & !is.null(threshold)){
df_pred<-ifelse(df_pred >= threshold_value, 1, 0)
}
df_pred<-as.numeric(df_pred)
df_true<-as.numeric(df_true)
#get R2
rsq<-function(df_pred, df_true){
(1- sum((df_pred - df_true) ^ 2)/sum((df_true - mean(df_true))^2))
}
#get ROC PLOT
roc_plot<- function(df_pred, df_true){
pROC_obj <- roc(df_true, df_pred,
smoothed = TRUE,
# arguments for ci
ci=TRUE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE,
print.auc=TRUE, show.thres=TRUE)
sens.ci <- ci.se(pROC_obj)
plot(sens.ci, type="shape", col="lightblue")
plot(sens.ci, type="bars")
}
if (eval_metric == "confusion matrix") {
cm<- caret::confusionMatrix(as.factor(df_pred), as.factor(df_true)) #The functions requires that the factors have exactly the same levels
res<-cm
}
else if (eval_metric == "logloss") {
ll<- Metrics::logLoss(df_true, df_pred) #computes the average log loss between two numeric vectors
res<-ll
}
else if (eval_metric == "roc") {
roc<- roc_plot(df_pred, df_true)
res<-roc
}
else if (eval_metric == "rmse") {
rmse<- Metrics::rmse(df_true, df_pred)
res<-rmse
}
else if (eval_metric == "mae") {
mae<- Metrics::mae(df_true, df_pred)
res<-mae
}
else if (eval_metric == "rsqure"){
r2<- rsq(df_pred, df_true)
res<-r2
}
else if (eval_metric == "quantile" & !is.null(bin)){
qt <- data.frame( response = df_pred,  actual= df_true) %>%
arrange(response) %>%
mutate(bin_value = ntile(response, bin)) %>%
group_by(bin_value) %>%
summarise(sum_actual= mean(actual), sum_pred = mean(response), .groups = 'drop')
qt<-as.data.frame(qt)
qt1<-qt[,c(1,2)]
qt1$Group <- rep("Actual", nrow(qt1))
colnames(qt1)[2] <- "Value"
qt2<-qt[,c(1,3)]
qt2$Group <- rep("Predict", nrow(qt2))
colnames(qt2)[2] <- "Value"
qt<-rbind(qt1, qt2)
res = ggplot(data=qt,
aes(x=bin_value, y=Value, colour= Group)) +
geom_line() + labs(title="Quantile Plot", x ="Bin", y = "Value") +
theme_bw()
}
else if (eval_metric == "brier"){
#res <- list()
#res[[1]] <- "Brier Score"
#res[[2]] <-mean((df_pred- df_true)^2)
res <-mean((df_pred- df_true)^2)
}
else stop ("ERROR: Please select vaild evaluation matrix")
return(res)
}
eval_fun(xtab$pred, xtab$truth, eval_metric = "quantile")
View(xtab)
eval_fun(xtab$pred, xtab$truth, eval_metric = "roc")
library(utlbia)
library("ggplot2")
library(cowplot)
library(dplyr)
library(knitr)
library(utlbia)
library(ggplot2)
library(cowplot)
library(dplyr)
library(knitr)
library(utlbia)
library(ggplot2)
library("cowplot")
library(dplyr)
library(knitr)
